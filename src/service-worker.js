self.addEventListener('install', event => {
  let CACHE_NAME = 'xyz-cache';
  let urlsToCache = ['/', '/styles/main.css', '/scripts/bundle.js'];
  event.waitUntil(
    /* open method available on caches, takes in the name of cache as the first parameter. It returns a promise that resolves to the instance of cache
    All the URLS above can be added to cache using the addAll method. */
    caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))
  );
});

self.addEventListener('activate', event => {
  let cacheWhitelist = ['products-v2']; // products-v2 is the name of the new cache

  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          /* Deleting all the caches except the ones that are in cacheWhitelist array */
          if (cacheWhitelist.indexOf(cacheName) === -1) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

/* Fetch event handler for responding to GET requests with the cached assets */
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.open('products-v2').then(cache => {
      /* Checking if the request is already present in the cache. If it is present, sending it directly to the client */
      return cache.match(event.request).then(response => {
        if (response) {
          console.log(
            'Cache hit! Fetching response from cache',
            event.request.url
          );
          return response;
        }
        /* If the request is not present in the cache, we fetch it from the server and then put it in cache for subsequent requests. */
        fetch(event.request).then(response => {
          cache.put(event.request, response.clone());
          return response;
        });
      });
    })
  );
});

/* Notification.permission can have one of these three values: default, granted or denied. */
if (Notification.permission === 'default') {
  /* The Notification.requestPermission() method shows a notification permission prompt to the user. It returns a promise that resolves to the value of permission*/
  Notification.requestPermission().then(result => {
    if (result === 'denied') {
      console.log('Permission denied');
      return;
    }

    if (result === 'granted') {
      console.log('Permission granted');
      /* This means the user has clicked the Allow button. We’re to get the subscription token generated by the browser and store it in our database.

      The subscription token can be fetched using the getSubscription method available on pushManager of the serviceWorkerRegistration object. If subscription is not available, we subscribe using the subscribe method available on pushManager. The subscribe method takes in an object.
      */

      serviceWorkerRegistration.pushManager
        .getSubscription()
        .then(subscription => {
          if (!subscription) {
            const applicationServerKey = '';
            serviceWorkerRegistration.pushManager.subscribe({
              userVisibleOnly: true, // All push notifications from server should be displayed to the user
              applicationServerKey // VAPID Public key
            });
          } else {
            saveSubscriptionInDB(subscription, userId); // A method to save subscription token in the database
          }
        });
    }
  });
}

self.addEventListener('push', event => {
  let options = {
    body: event.data.body,
    icon: 'images/example.png'
  };
  event.waitUntil(
    /* The showNotification method is available on the registration object of the service worker.
    The first parameter to showNotification method is the title of notification, and the second parameter is an object */
    self.registration.showNotification(event.data.title, options)
  );
});

// let dbInstance;

// openIdbRequest.onsuccess = event => {
//   dbInstance = event.target.result;
//   console.log('booksdb is opened successfully');
// };

// openIdbRequest.onerror = event => {
//   console.log('There was an error in opening booksdb database');
// };

// let openIdbRequest = window.indexedDB.open('booksdb', 2); // New Version - 2

// /* Success and error event handlers remain the same.
// The onupgradeneeded method gets called when the version of the database changes. */
// openIdbRequest.onupgradeneeded = event => {
//   let db = event.target.result;
//   if (!db.objectStoreNames.contains('books')) {
//     let objectstore = db.createObjectStore('books', { keyPath: 'id' });
//   }

//   let oldVersion = event.oldVersion;
//   let newVersion = event.newVersion;

//   /* The users tables should be added for version 2. If the existing version is 1, it will be upgraded to 2, and the users object store will be created. */
//   if (oldVersion === 1) {
//     db.createObjectStore('users', { keyPath: 'id' });
//   }
// };

// let transaction = dbInstance.transaction('books')
// let objectstore = transaction.objectstore('books')

// let bookRecord = {
//   id: '1',
//   name: ’The Alchemist',
//     author: 'Paulo Coelho'
// }
// let addBookRequest = objectstore.add(bookRecord)

// addBookRequest.onsuccess = (event) => {
//   console.log('Book record added successfully')
// }

// addBookRequest.onerror = (event) => {
//   console.log(’There was an error in adding book record')
// }

// let modifyBookRequest = objectstore.put(bookRecord) // put method takes in an object as the parameter
// modifyBookRequest.onsuccess = (event) => {
//   console.log('Book record updated successfully')
// }

// let transaction = dbInstance.transaction('books')
// let objectstore = transaction.objectstore('books')

// /* get method takes in the id of the record */
// let getBookRequest = objectstore.get(1)

// getBookRequest.onsuccess = (event) => {
//   /* event.target.result contains the matched record */
//   console.log('Book record', event.target.result)
// }

// getBookRequest.onerror = (event) => {
//   console.log('Error while retrieving the book record.')
// }
